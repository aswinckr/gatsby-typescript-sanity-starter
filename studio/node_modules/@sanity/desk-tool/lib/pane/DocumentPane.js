"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _promiseLatest = _interopRequireDefault(require("promise-latest"));

var _dateFns = require("date-fns");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _documentActionUtils = require("part:@sanity/base/util/document-action-utils");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _preview = require("part:@sanity/base/preview");

var _spinner = _interopRequireDefault(require("part:@sanity/components/loading/spinner"));

var _history = _interopRequireDefault(require("part:@sanity/base/datastore/history"));

var _document = _interopRequireDefault(require("part:@sanity/base/datastore/document"));

var _tabbed = _interopRequireDefault(require("part:@sanity/components/panes/tabbed"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/snackbar/default"));

var _hotkeys = _interopRequireDefault(require("part:@sanity/components/typography/hotkeys"));

var _formBuilder = require("part:@sanity/form-builder");

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _ = require("../../");

var _withInitialValue = _interopRequireDefault(require("../utils/withInitialValue"));

var _copyDocument = _interopRequireDefault(require("../utils/copyDocument"));

var _UseState = _interopRequireDefault(require("../utils/UseState"));

var _ConfirmUnpublish = _interopRequireDefault(require("../components/ConfirmUnpublish"));

var _ConfirmDelete = _interopRequireDefault(require("../components/ConfirmDelete"));

var _InspectView = _interopRequireDefault(require("../components/InspectView"));

var _InspectHistory = _interopRequireDefault(require("../components/InspectHistory"));

var _DocTitle = _interopRequireDefault(require("../components/DocTitle"));

var _TimeAgo = _interopRequireDefault(require("../components/TimeAgo"));

var _index = _interopRequireDefault(require("../components/DocumentStatusBar/index"));

var _Delay = _interopRequireDefault(require("../utils/Delay"));

var _isNarrowScreen = _interopRequireDefault(require("../utils/isNarrowScreen"));

var _windowWidth = _interopRequireDefault(require("../utils/windowWidth"));

var _History = _interopRequireDefault(require("./History"));

var _DocumentPane = _interopRequireDefault(require("./styles/DocumentPane.css"));

var _FormView = _interopRequireDefault(require("./Editor/FormView"));

var _Actions = _interopRequireDefault(require("./Editor/Actions"));

var _history2 = require("./Editor/history");

var _documentPaneMenuItems = _interopRequireDefault(require("./styles/documentPaneMenuItems.css"));

var _documentPaneFooterActions = require("./documentPaneFooterActions");

var _documentPaneMenuItems2 = require("./documentPaneMenuItems");

var _validation = require("@sanity/validation");

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEBUG_HISTORY_TRANSITION = false;
var CURRENT_REVISION_FLAG = '-';
var KEY_I = 73;
var KEY_O = 79;
var KEY_P = 80;

function debugHistory() {
  if (DEBUG_HISTORY_TRANSITION) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var logLine = typeof args[0] === 'string' ? "[HISTORY] ".concat(args[0]) : '[HISTORY] '; // eslint-disable-next-line no-console

    console.log(logLine, ...args.slice(1));
  }
}

function isInspectHotkey(event) {
  return event.ctrlKey && event.keyCode === KEY_I && event.altKey && !event.shiftKey;
}

function isPublishHotkey(event) {
  return event.ctrlKey && event.keyCode === KEY_P && event.altKey && !event.shiftKey;
}

function isPreviewHotkey(event) {
  return event.ctrlKey && event.keyCode === KEY_O && event.altKey && !event.shiftKey;
}

var isValidationError = marker => marker.type === 'validation' && marker.level === 'error';

var INITIAL_DOCUMENT_STATE = {
  isLoading: true,
  deletedSnapshot: null,
  snapshot: null
};
var INITIAL_HISTORICAL_DOCUMENT_STATE = {
  isLoading: false,
  snapshot: null,
  prevSnapshot: null
};
var INITIAL_HISTORY_STATE = {
  isEnabled: (0, _history2.historyIsEnabled)(),
  isLoading: true,
  error: null,
  events: []
};
var INITIAL_STATE = {
  markers: [],
  isCreatingDraft: false,
  isMenuOpen: false,
  isPublishing: false,
  isReconnecting: false,
  isRestoring: false,
  isSaving: false,
  isUnpublishing: false,
  hasNarrowScreen: (0, _isNarrowScreen.default)(),
  transactionResult: null,
  validationPending: true,
  inspect: false,
  showSavingStatus: false,
  showConfirmDelete: false,
  showConfirmUnpublish: false,
  showValidationTooltip: false,
  showConfirmDiscardDraft: false,
  draft: INITIAL_DOCUMENT_STATE,
  published: INITIAL_DOCUMENT_STATE,
  historical: INITIAL_HISTORICAL_DOCUMENT_STATE,
  historyState: INITIAL_HISTORY_STATE
};

function documentEventToState(event) {
  switch (event.type) {
    case 'rebase':
    case 'create':
    case 'createIfNotExists':
    case 'snapshot':
      {
        return {
          deletedSnapshot: null,
          snapshot: event.document
        };
      }

    case 'mutation':
      {
        return {
          deletedSnapshot: event.deletedSnapshot,
          snapshot: event.document ? _objectSpread({}, event.document, {
            // todo: The following line is a temporary workaround for a problem with the mutator not
            // setting updatedAt on patches applied optimistic when they are received from server
            // can be removed when this is fixed
            _updatedAt: new Date().toISOString()
          }) : event.document
        };
      }

    case 'reconnect':
      {
        return {};
      }

    case 'committed':
      {
        // note: we *could* use this in conjunction with <document>.commit()
        // by setting this.state.isSaving=true before calling <document>.commit and setting to false
        // again when we get the 'committed' event back.
        // However, calling <document>.commit() doesn't necessarily result in a commit actually being done,
        // and thus we are not guaranteed to get a 'committed' event back after a call to
        // <document>.commit(), which means we could easily get into a situation where the
        // `isSaving` state stays around forever.
        return {};
      }

    case 'error':
      {
        return {};
      }

    default:
      {
        // eslint-disable-next-line no-console
        console.log('Unhandled document event type "%s"', event.type, event);
        return {};
      }
  }
}

function exists(draft, published) {
  return draft.snapshot || published.snapshot;
}

function isRecoverable(draft, published) {
  return !exists(draft, published) && (draft.deletedSnapshot || published.deletedSnapshot);
}

var _default = (0, _withInitialValue.default)((_temp = _class = class DocumentPane extends _react.default.PureComponent {
  constructor(props, _context) {
    var _this;

    super(props);
    _this = this;

    _defineProperty(this, "state", _objectSpread({}, INITIAL_STATE, {
      hasNarrowScreen: (0, _isNarrowScreen.default)()
    }));

    _defineProperty(this, "patchChannel", _formBuilder.FormBuilder.createPatchChannel());

    _defineProperty(this, "formRef", _react.default.createRef());

    _defineProperty(this, "validateDocument",
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      var _this$getDocumentSnap = _this.getDocumentSnapshots(),
          draft = _this$getDocumentSnap.draft,
          published = _this$getDocumentSnap.published;

      var doc = draft || published;

      if (!doc || !doc._type) {
        return [];
      }

      var type = _schema.default.get(doc._type);

      if (!type) {
        // eslint-disable-next-line no-console
        console.warn('Schema for document type "%s" not found, skipping validation');
        return [];
      }

      var markers = yield (0, _validation.validateDocument)(doc, _schema.default);

      _this.setStateIfMounted({
        markers,
        validationPending: false
      });

      return markers;
    }));

    _defineProperty(this, "receiveDraftEvent", event => {
      if (event.type !== 'mutation') {
        return;
      } // Broadcast incoming patches to input components that applies patches on their own
      // Note: This is *experimental*


      this.patchChannel.receivePatches({
        patches: event.patches,
        snapshot: event.document
      });
    });

    _defineProperty(this, "handleHistorySelect", event => {
      var paneContext = this.context;
      var eventisCurrent = this.state.history.events[0] === event;
      paneContext.setParams(_objectSpread({}, paneContext.params, {
        rev: eventisCurrent ? CURRENT_REVISION_FLAG : event.rev
      }), {
        recurseIfInherited: true
      });
    });

    _defineProperty(this, "handleSplitPane", () => {
      this.context.duplicateCurrent();
    });

    _defineProperty(this, "handleSetActiveView", function () {
      _this.context.setView(...arguments);
    });

    _defineProperty(this, "handleShowConfirmDelete", () => {
      this.setState({
        showConfirmDelete: true
      });
    });

    _defineProperty(this, "handleShowConfirmUnpublish", () => {
      this.setState({
        showConfirmUnpublish: true
      });
    });

    _defineProperty(this, "handleClosePane", () => {
      this.context.closeCurrent();
    });

    _defineProperty(this, "setSavingStatus", (0, _debounce2.default)(() => {
      this.setState({
        showSavingStatus: false
      });
    }, 1500, {
      trailing: true
    }));

    _defineProperty(this, "handleToggleInspect", () => {
      var _this$state = this.state,
          draft = _this$state.draft,
          published = _this$state.published;
      var value = draft.snapshot || published.snapshot;

      if (!value) {
        return;
      }

      this.setState(prevState => ({
        inspect: !prevState.inspect
      }));
    });

    _defineProperty(this, "handleKeyUp", event => {
      if (event.keyCode === 'Escape' && this.state.showValidationTooltip) {
        return this.setState({
          showValidationTooltip: false
        });
      }

      if (isInspectHotkey(event) && !this.historyIsOpen()) {
        return this.handleToggleInspect();
      }

      if (isPublishHotkey(event)) {
        return this.handlePublishRequested();
      }

      if (isPreviewHotkey(event)) {
        var _this$getDocumentSnap2 = this.getDocumentSnapshots(),
            draft = _this$getDocumentSnap2.draft,
            published = _this$getDocumentSnap2.published;

        var item = (0, _documentPaneMenuItems2.getProductionPreviewItem)({
          draft,
          published
        });
        return item && item.url && window.open(item.url);
      }

      return null;
    });

    _defineProperty(this, "handleDiscardDraft", () => {
      this.setState({
        showConfirmDiscardDraft: true
      });
    });

    _defineProperty(this, "handleConfirmDiscardDraft", () => {
      this.setState({
        showConfirmDiscardDraft: false
      });
      this.draft.delete();
      this.draft.commit().subscribe(() => {// todo: error handling
      });
    });

    _defineProperty(this, "handleCancelDiscardDraft", () => {
      this.setState({
        showConfirmDiscardDraft: false
      });
    });

    _defineProperty(this, "handlePublishRequested", () => {
      var _this$state2 = this.state,
          markers = _this$state2.markers,
          validationPending = _this$state2.validationPending;
      var errors = markers.filter(isValidationError);
      var hasErrors = errors.length > 0;

      if (validationPending || hasErrors) {
        this.setState(prevState => ({
          showValidationTooltip: !prevState.showValidationTooltip
        }));
        return;
      }

      if (!this.canPublish()) {
        return;
      }

      this.handlePublish();
    });

    _defineProperty(this, "handleCancelUnpublish", () => {
      this.setState({
        showConfirmUnpublish: false
      });
    });

    _defineProperty(this, "handleCancelDelete", () => {
      this.setState({
        showConfirmDelete: false
      });
    });

    _defineProperty(this, "handleConfirmUnpublish", () => {
      this.handleUnpublish();
      this.setState({
        showConfirmUnpublish: false
      });
    });

    _defineProperty(this, "handleConfirmDelete", () => {
      this.handleDelete();
      this.setState({
        showConfirmDelete: false
      });
    });

    _defineProperty(this, "handleHideInspector", () => {
      this.setState({
        inspect: false
      });
    });

    _defineProperty(this, "handleMenuAction", item => {
      if (item.action === 'production-preview') {
        window.open(item.url);
        return true;
      }

      if (item.action === 'delete') {
        this.setState({
          showConfirmDelete: true
        });
        return true;
      }

      if (item.action === 'unpublish') {
        this.setState({
          showConfirmUnpublish: true
        });
        return true;
      }

      if (item.action === 'duplicate') {
        this.handleCreateCopy();
        return true;
      }

      if (item.action === 'inspect') {
        this.setState({
          inspect: true
        });
        return true;
      }

      if (item.action === 'browseHistory') {
        this.handleOpenHistory();
        return true;
      }

      this.setState({
        isMenuOpen: false
      });
      return false;
    });

    _defineProperty(this, "handleCloseValidationResults", () => {
      this.setState({
        showValidationTooltip: false
      });
    });

    _defineProperty(this, "handleToggleValidationResults", () => {
      this.setState(prevState => ({
        showValidationTooltip: !prevState.showValidationTooltip
      }));
    });

    _defineProperty(this, "setHistoryState", function (nextHistoryState) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _noop2.default;

      _this.setState((_ref2) => {
        var currentHistoryState = _ref2.historyState;
        return {
          historyState: _objectSpread({}, currentHistoryState, {}, nextHistoryState)
        };
      }, cb);
    });

    _defineProperty(this, "handleOpenHistory", () => {
      if (!this.canShowHistoryList() || this.historyIsOpen()) {
        return;
      }

      this.context.setParams(_objectSpread({}, this.context.params, {
        rev: CURRENT_REVISION_FLAG
      }), {
        recurseIfInherited: true
      });
    });

    _defineProperty(this, "handleCloseHistory", ctx => {
      var context = this.context || ctx;

      if (this._historyEventsSubscription) {
        this._historyEventsSubscription.unsubscribe();
      }

      var _context$params = context.params,
          rev = _context$params.rev,
          params = _objectWithoutProperties(_context$params, ["rev"]);

      if (rev) {
        // If there is a revision in the URL, remove it and let componentDidUpdate handle closing transition
        context.setParams(params, {
          recurseIfInherited: true
        });
      }
    });

    _defineProperty(this, "handleDelete", () => {
      var documentId = this.props.options.id;

      var tx = _client.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId)).delete((0, _draftUtils.getDraftId)(documentId));

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: "An error occurred while attempting to delete document.\n              This usually means that you attempted to delete a document that other documents\n              refers to.",
        error
      }))).subscribe(result => {
        this.setStateIfMounted({
          transactionResult: result
        });
      });
    });

    _defineProperty(this, "handleClearTransactionResult", () => {
      this.setStateIfMounted({
        transactionResult: null
      });
    });

    _defineProperty(this, "handleUnpublish", () => {
      var documentId = this.props.options.id;
      var published = this.state.published;

      var tx = _client.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId));

      if (published.snapshot) {
        tx = tx.createIfNotExists(_objectSpread({}, (0, _omit2.default)(published.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getDraftId)(documentId)
        }));
      }

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: "An error occurred while attempting to unpublish document.\n        This usually means that you attempted to unpublish a document that other documents\n        refers to.",
        error
      }))).subscribe(result => {
        this.setStateIfMounted({
          transactionResult: result
        });
      });
    });

    _defineProperty(this, "handlePublish", () => {
      if (!this.canPublish()) {
        return;
      }

      var documentId = this.props.options.id;
      var _this$state3 = this.state,
          draft = _this$state3.draft,
          published = _this$state3.published;
      this.setState({
        isPublishing: true
      });

      var tx = _client.default.observable.transaction();

      if (!published || !published.snapshot) {
        // If the document has not been published, we want to create it - if it suddenly exists
        // before being created, we don't want to overwrite if, instead we want to yield an error
        tx.create(_objectSpread({}, (0, _omit2.default)(draft.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getPublishedId)(documentId)
        }));
      } else {
        // If it exists already, we only want to update it if the revision on the remote server
        // matches what our local state thinks it's at
        tx.patch((0, _draftUtils.getPublishedId)(documentId), {
          // Hack until other mutations support revision locking
          unset: ['_reserved_prop_'],
          ifRevisionID: published.snapshot._rev
        }).createOrReplace(_objectSpread({}, (0, _omit2.default)(draft.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getPublishedId)(documentId)
        }));
      }

      tx.delete((0, _draftUtils.getDraftId)(documentId)); // @todo add error handling for revision mismatch

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: 'An error occurred while attempting to publishing document',
        error
      }))).subscribe({
        next: result => {
          this.setState({
            transactionResult: result
          });
        },
        complete: () => {
          this.setStateIfMounted({
            isPublishing: false,
            didPublish: true
          });
        }
      });
    });

    _defineProperty(this, "handleRestoreRevision", (_ref3) => {
      var id = _ref3.id,
          rev = _ref3.rev;

      var transactionResult$ = _history.default.restore(id, rev).pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: 'An error occurred while attempting to restore the document',
        error
      })), (0, _operators.map)(transactionResult => ({
        transactionResult
      })));

      (0, _rxjs.concat)((0, _rxjs.of)({
        isRestoring: true
      }), transactionResult$, (0, _rxjs.of)({
        isRestoring: false
      })).subscribe(nextState => {
        this.setStateIfMounted(nextState);
        this.setHistoryState(INITIAL_HISTORY_STATE);

        var _this$context$params = this.context.params,
            oldRev = _this$context$params.rev,
            params = _objectWithoutProperties(_this$context$params, ["rev"]);

        var newRevision = (0, _get2.default)(nextState, 'transactionResult.result.transactionId');

        if (newRevision && oldRev) {
          // If there is a revision in the URL, replace it with the new one
          this.context.setParams(_objectSpread({}, params, {
            rev: newRevision
          }), {
            recurseIfInherited: true
          });
        }
      });
    });

    _defineProperty(this, "handleChange", event => {
      var _this$state4 = this.state,
          published = _this$state4.published,
          draft = _this$state4.draft;
      var initialValue = this.getInitialValue();

      if (this.isLiveEditEnabled()) {
        // No drafting, patch and commit the published document
        this.published.createIfNotExists(_objectSpread({
          _id: this.getPublishedId()
        }, initialValue));
        this.published.patch(event.patches);
      } else {
        if (!draft.snapshot) {
          this.draft.createIfNotExists(_objectSpread({}, (0, _omit2.default)(published.snapshot, '_updatedAt'), {
            _id: this.getDraftId()
          }, initialValue));
        }

        this.draft.patch(event.patches);
      }

      this.commit();
    });

    _defineProperty(this, "handleCreateCopy", () => {
      var paneContext = this.context;

      var _this$getDocumentSnap3 = this.getDocumentSnapshots(),
          draft = _this$getDocumentSnap3.draft,
          published = _this$getDocumentSnap3.published;

      var omitProps = ['_createdAt', '_updatedAt'];
      var duplicatedDocument = this.isLiveEditEnabled() ? (0, _copyDocument.default)(published, {
        omit: omitProps
      }) : (0, _draftUtils.newDraftFrom)((0, _copyDocument.default)(draft || published, {
        omit: omitProps
      }));
      this.duplicate$ = _document.default.create(duplicatedDocument).subscribe(copied => paneContext.replaceCurrent({
        id: (0, _draftUtils.getPublishedId)(copied._id)
      }));
    });

    _defineProperty(this, "handleMenuToggle", evt => {
      evt.stopPropagation();
      this.setState(prevState => ({
        isMenuOpen: !prevState.isMenuOpen
      }));
    });

    _defineProperty(this, "handleEditAsActualType", () => {
      var paneContext = this.context;

      var _this$getDocumentSnap4 = this.getDocumentSnapshots(),
          draft = _this$getDocumentSnap4.draft,
          published = _this$getDocumentSnap4.published;

      paneContext.navigateIntent('edit', {
        id: (0, _draftUtils.getPublishedId)((draft || published)._id),
        type: draft._type || published._type
      });
    });

    _defineProperty(this, "handleSetFocus", path => {
      if (this.formRef.current) {
        this.formRef.current.handleFocus(path);
      }
    });

    _defineProperty(this, "setStateIfMounted", function () {
      if (!_this._isMounted) {
        return;
      }

      _this.setState(...arguments);
    });

    _defineProperty(this, "commit", (0, _throttle2.default)(() => {
      var currentDoc = this.isLiveEditEnabled() ? this.published : this.draft;
      this.setStateIfMounted({
        isSaving: true
      });
      currentDoc.commit().subscribe({
        next: () => {// todo
        },
        error: _error => {// todo
        },
        complete: () => {
          this.setStateIfMounted({
            isSaving: false,
            showSavingStatus: true
          });
          this.setSavingStatus();
        }
      });
    }, 1000, {
      leading: true,
      trailing: true
    }));

    _defineProperty(this, "handleRestoreDeleted", () => {
      var _this$state5 = this.state,
          draft = _this$state5.draft,
          published = _this$state5.published;
      var commits = [];

      if (draft.deletedSnapshot) {
        this.draft.createIfNotExists(draft.deletedSnapshot);
        commits.push(this.draft.commit());
      } else if (published.deletedSnapshot) {
        this.published.createIfNotExists(published.deletedSnapshot);
        commits.push(this.published.commit());
      }

      commits.forEach(c => {
        c.subscribe({
          next: () => {}
        });
      });
    });

    _defineProperty(this, "renderPublishButtonTooltip", (errors, published) => {
      if (errors.length > 0) {
        return _react.default.createElement("span", null, "Fix errors before publishing");
      }

      return _react.default.createElement("span", {
        className: _documentPaneMenuItems.default.menuItem
      }, published ? 'Publish changes' : 'Publish', errors.length < 1 && _react.default.createElement("span", {
        className: _documentPaneMenuItems.default.hotkey
      }, _react.default.createElement(_hotkeys.default, {
        keys: ['Ctrl', 'Alt', 'P']
      })));
    });

    _defineProperty(this, "renderActions", () => {
      var _this$getDocumentSnap5 = this.getDocumentSnapshots(),
          draft = _this$getDocumentSnap5.draft,
          published = _this$getDocumentSnap5.published;

      var markers = this.state.markers;
      var typeName = this.props.options.type;

      var schemaType = _schema.default.get(typeName);

      var showValidationTooltip = this.state.showValidationTooltip;

      if (this.historyIsOpen()) {
        return null;
      }

      return _react.default.createElement(_Actions.default, {
        value: draft || published,
        markers: markers,
        type: schemaType,
        isLiveEditEnabled: this.isLiveEditEnabled(),
        showValidationTooltip: showValidationTooltip,
        onCloseValidationResults: this.handleCloseValidationResults,
        onToggleValidationResults: this.handleToggleValidationResults,
        onFocus: this.handleSetFocus
      });
    });

    _defineProperty(this, "renderHistoryFooter", () => {
      var selectedEvent = this.findSelectedHistoryEvent();
      var paneKey = this.props.paneKey;
      var _this$state6 = this.state,
          historyState = _this$state6.historyState,
          isReconnecting = _this$state6.isReconnecting,
          isRestoring = _this$state6.isRestoring;
      var isLatestEvent = historyState.events[0] === selectedEvent;
      var historyStatus = selectedEvent ? _react.default.createElement(_react.default.Fragment, null, "Changed ", _react.default.createElement(_TimeAgo.default, {
        time: selectedEvent.endTime
      }), " ", isLatestEvent && _react.default.createElement(_react.default.Fragment, null, " (latest)")) : null;
      var documentStatusProps = {
        actions: [{
          color: 'primary',
          disabled: isRestoring || isReconnecting || isLatestEvent,
          id: 'restore',
          label: 'Restore',
          handleClick: () => {
            this.handleRestoreRevision({
              id: selectedEvent.displayDocumentId,
              rev: selectedEvent.rev
            });
          }
        }],
        historyStatus,
        idPrefix: paneKey,
        isSyncing: isRestoring
      };
      return _react.default.createElement(_index.default, documentStatusProps);
    });

    _defineProperty(this, "renderFooter", () => {
      var _this$getDocumentSnap6 = this.getDocumentSnapshots(),
          draft = _this$getDocumentSnap6.draft,
          published = _this$getDocumentSnap6.published;

      var _this$props = this.props,
          initialValue = _this$props.initialValue,
          options = _this$props.options,
          paneKey = _this$props.paneKey;
      var value = draft || published || initialValue;
      var _this$state7 = this.state,
          isCreatingDraft = _this$state7.isCreatingDraft,
          isPublishing = _this$state7.isPublishing,
          isReconnecting = _this$state7.isReconnecting,
          isUnpublishing = _this$state7.isUnpublishing,
          markers = _this$state7.markers,
          showSavingStatus = _this$state7.showSavingStatus,
          showConfirmDiscardDraft = _this$state7.showConfirmDiscardDraft;
      var validation = markers.filter(marker => marker.type === 'validation');
      var errors = validation.filter(marker => marker.level === 'error');
      var onShowHistory = this.handleOpenHistory;
      var isLiveEditEnabled = this.isLiveEditEnabled();
      var canShowHistory = this.canShowHistoryList(); // get enabled actions value

      var typeName = options.type;

      var schemaType = _schema.default.get(typeName);

      var enabledActions = (0, _documentActionUtils.resolveEnabledActions)(schemaType);
      var badges = [!isLiveEditEnabled && published && {
        id: 'published',
        label: 'Published',
        color: 'success',
        title: "Published ".concat((0, _dateFns.distanceInWordsToNow)(published._updatedAt, {
          addSuffix: true
        }))
      }, !isLiveEditEnabled && draft && {
        id: 'draft',
        label: 'Draft',
        color: 'warning'
      }, isLiveEditEnabled && {
        id: 'live',
        label: 'Live',
        color: 'danger'
      }].filter(Boolean);
      var actions = (0, _documentPaneFooterActions.getDocumentPaneFooterActions)({
        draft,
        enabledActions,
        errors,
        handlers: {
          discardChanges: this.handleDiscardDraft,
          publish: this.handlePublishRequested,
          unpublish: this.handleShowConfirmUnpublish,
          duplicate: this.handleCreateCopy,
          delete: this.handleShowConfirmDelete
        },
        isCreatingDraft,
        isLiveEditEnabled,
        isPublishing,
        isReconnecting,
        isUnpublishing,
        published
      });
      var historyStatus = value && value._updatedAt ? _react.default.createElement(_react.default.Fragment, null, "Updated ", _react.default.createElement(_TimeAgo.default, {
        time: value._updatedAt
      })) : _react.default.createElement(_react.default.Fragment, null, "Empty");
      var confirmationDialog;

      if (showConfirmDiscardDraft) {
        confirmationDialog = {
          message: _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("strong", null, "Are you sure"), " you want to discard all changes since last published?"),
          confirmText: 'Discard',
          handleConfirm: this.handleConfirmDiscardDraft,
          handleCancel: this.handleCancelDiscardDraft
        };
      }

      var documentStatusProps = {
        badges,
        actions,
        historyStatus,
        idPrefix: paneKey,
        isDisconnected: isReconnecting,
        isHistoryAvailable: canShowHistory,
        isSyncing: showSavingStatus,
        onHistoryStatusClick: onShowHistory,
        confirmationDialog
      };
      return _react.default.createElement(_index.default, documentStatusProps);
    });

    this.setup(props.options.id, _context);
  }

  setup(documentId, context) {
    this.dispose();
    var publishedId = (0, _draftUtils.getPublishedId)(documentId);
    var draftId = (0, _draftUtils.getDraftId)(documentId);

    var _checkoutPair = (0, _formBuilder.checkoutPair)({
      publishedId,
      draftId
    }),
        published = _checkoutPair.published,
        draft = _checkoutPair.draft;

    this.published = published;
    this.draft = draft;
    this.validateLatestDocument = (0, _debounce2.default)((0, _promiseLatest.default)(this.validateDocument, 300));

    if (this.props.urlParams.rev) {
      if ((0, _history2.historyIsEnabled)()) {
        this.handleFetchHistoricalDocument();
      } else {
        this.handleCloseHistory(context);
      }
    }

    var published$ = this.published.events;
    var draft$ = this.draft.events.pipe((0, _operators.tap)(this.receiveDraftEvent));
    this.subscription = (0, _rxjs.merge)(published$.pipe((0, _operators.map)(event => _objectSpread({}, event, {
      version: 'published'
    }))), draft$.pipe((0, _operators.map)(event => _objectSpread({}, event, {
      version: 'draft'
    })))).pipe((0, _operators.switchMap)(event => event.type === 'reconnect' ? (0, _rxjs.timer)(500).pipe((0, _operators.mapTo)(event)) : (0, _rxjs.of)(event)), (0, _operators.catchError)((err, _caught$) => {
      // eslint-disable-next-line no-console
      console.error(err);
      return (0, _rxjs.of)({
        type: 'error',
        error: err
      });
    })).subscribe(event => {
      this.setState(prevState => {
        var version = event.version; // either 'draft' or 'published'

        return {
          isReconnecting: event.type === 'reconnect',
          validationPending: true,
          error: event.type === 'error' ? event.error : null,
          [version]: _objectSpread({}, prevState[version] || {}, {}, documentEventToState(event), {
            isLoading: false
          })
        };
      }, this.validateLatestDocument);
    });
  }

  getActiveViewId() {
    var views = this.props.views;
    return this.context.params.view || views[0] && views[0].id;
  }

  getDraftId() {
    return (0, _draftUtils.getDraftId)(this.props.options.id);
  }

  getPublishedId() {
    return (0, _draftUtils.getPublishedId)(this.props.options.id);
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.options.id !== this.props.options.id) {
      this.setup(this.props.options.id);
    }

    this.handleHistoryTransition(prevProps, prevState);
  }

  handleHistoryTransition(prevProps, prevState) {
    var next = this.props.urlParams;
    var prev = prevProps.urlParams;
    var selectedRev = next.rev;
    var revChanged = next.rev !== prev.rev;

    var rev = next.rev,
        params = _objectWithoutProperties(next, ["rev"]);

    var historyEvents = this.state.historyState.events;
    var documentsAreLoaded = !this.state.draft.isLoading && !this.state.published.isLoading;
    var wasNotLoaded = prevState.draft.isLoading || prevState.published.isLoading;
    var historicalSnapshot = this.state.historical.snapshot;
    var isLoadingSnapshot = this.state.historical.isLoading;
    var shouldLoadHistoricalSnapshot = revChanged || !isLoadingSnapshot && selectedRev && !historicalSnapshot;
    var shouldLoadHistory = Boolean(documentsAreLoaded && !wasNotLoaded && historyEvents.length === 0 && selectedRev);

    if (prevState.historyState.isEnabled && !this.state.historyState.isEnabled) {
      this.handleCloseHistory();
    }

    if (shouldLoadHistory) {
      debugHistory('Fetch history events');
      this.handleFetchHistoryEvents();
    } // A new revision was selected, and we're not currently loading the snapshot


    if (shouldLoadHistoricalSnapshot) {
      this.handleFetchHistoricalDocument(rev);
    } // Transitioned to a different document


    if (rev && prevProps.options.id !== this.props.options.id) {
      debugHistory('Document ID changed, remove revision from URL'); // Tear out the revision from the URL, as well as the selected revision

      this.context.setParams(params, {
        recurseIfInherited: true
      });
      return;
    } // History was closed


    if (!rev && prev.rev) {
      debugHistory('History closed, reset history state');
      this.setHistoryState(INITIAL_HISTORY_STATE);
      this.setState({
        historical: INITIAL_HISTORICAL_DOCUMENT_STATE
      });
    }
  }

  handleFetchHistoricalDocument(atRev) {
    var isCurrent = atRev === CURRENT_REVISION_FLAG;

    if (isCurrent) {
      return;
    }

    var event = atRev ? this.findHistoryEventByRev(atRev) : this.findSelectedHistoryEvent();

    if (!event) {
      debugHistory('Could not find history event %s', atRev ? "for revision ".concat(atRev) : ' (selected)');
      return;
    }

    if (this._historyFetchDocSubscription) {
      this._historyFetchDocSubscription.unsubscribe();
    }

    this.setState((_ref4) => {
      var historical = _ref4.historical;
      return {
        historical: _objectSpread({}, historical, {
          snapshot: null,
          prevSnapshot: historical.snapshot || historical.prevSnapshot,
          isLoading: true
        })
      };
    });
    var id = event.displayDocumentId,
        rev = event.rev;
    debugHistory('Fetch historical document for rev %s', atRev);
    this._historyFetchDocSubscription = (0, _rxjs.from)(_history.default.getDocumentAtRevision(id, rev)).subscribe(newSnapshot => {
      this.setState((_ref5) => {
        var historical = _ref5.historical;
        return {
          historical: _objectSpread({}, historical, {
            isLoading: false,
            snapshot: newSnapshot,
            prevSnapshot: null
          })
        };
      });
    });
  }

  getDocumentSnapshots() {
    var _this$state8 = this.state,
        draft = _this$state8.draft,
        published = _this$state8.published;
    return {
      draft: draft.snapshot,
      published: published.snapshot
    };
  }

  getInitialValue() {
    var _this$state9 = this.state,
        draft = _this$state9.draft,
        published = _this$state9.published;
    var typeName = this.props.options.type;
    var base = {
      _type: typeName
    };
    return exists(draft, published) ? base : _objectSpread({}, base, {}, this.props.initialValue);
  }

  canShowHistoryList() {
    return this.context.siblingIndex === 0 && !this.props.isCollapsed && this.state.historyState.isEnabled;
  }

  componentDidMount() {
    this._isMounted = true;
    this.resizeSubscriber = _windowWidth.default.subscribe(() => {
      var historyEnabled = (0, _history2.historyIsEnabled)();
      var hasNarrowScreen = (0, _isNarrowScreen.default)();

      if (this.state.historyState.isEnabled !== historyEnabled) {
        this.setHistoryState({
          isEnabled: historyEnabled
        });
      }

      if (this.state.hasNarrowScreen !== hasNarrowScreen) {
        this.setState({
          hasNarrowScreen
        });
      }
    });
  }

  componentWillUnmount() {
    this._isMounted = false; // Cancel throttled commit since draft will be nulled on unmount

    this.commit.cancel(); // Instead, explicitly commit

    this.draft.commit().subscribe(() => {// todo: error handling
    });
    this.setSavingStatus.cancel();

    if (this.resizeSubscriber) {
      this.resizeSubscriber.unsubscribe();
    }

    this.dispose();
  }

  isLiveEditEnabled() {
    var selectedSchemaType = _schema.default.get(this.props.options.type);

    return selectedSchemaType.liveEdit === true;
  }

  historyIsOpen() {
    return Boolean(this.props.urlParams.rev);
  }

  canPublish() {
    var _this$state10 = this.state,
        markers = _this$state10.markers,
        validationPending = _this$state10.validationPending,
        draft = _this$state10.draft;
    var typeName = this.props.options.type;

    if (!draft.snapshot) {
      return false;
    }

    var errors = markers.filter(isValidationError);
    var hasErrors = errors.length > 0;

    if (validationPending || hasErrors) {
      return false;
    }

    var type = _schema.default.get(typeName);

    return (0, _documentActionUtils.isActionEnabled)(type, 'publish');
  }

  dispose() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }

    if (this.validateLatestDocument) {
      this.validateLatestDocument.cancel();
      this.validateLatestDocument = null;
    }

    if (this.duplicate$) {
      this.duplicate$.unsubscribe();
    }

    if (this._historyEventsSubscription) {
      this._historyEventsSubscription.unsubscribe();
    }

    if (this._historyFetchDocSubscription) {
      this._historyFetchDocSubscription.unsubscribe();
    }

    this.published = null;
    this.draft = null;
  }

  handleFetchHistoryEvents() {
    var _this$getDocumentSnap7 = this.getDocumentSnapshots(),
        draft = _this$getDocumentSnap7.draft,
        published = _this$getDocumentSnap7.published;

    if (this._historyEventsSubscription) {
      this._historyEventsSubscription.unsubscribe();
    }

    this._historyEventsSubscription = _history.default.historyEventsFor((0, _draftUtils.getPublishedId)((draft || published)._id)).pipe((0, _operators.map)((events, i) => {
      var newState = i === 0 ? {
        events,
        isLoading: false
      } : {
        events
      };
      this.setHistoryState(newState);
      return events;
    })).subscribe();
  }

  renderDeleted() {
    return _react.default.createElement("div", {
      className: _DocumentPane.default.deletedDocument
    }, _react.default.createElement("div", {
      className: _DocumentPane.default.deletedDocumentInner
    }, _react.default.createElement("h3", null, "This document just got deleted"), _react.default.createElement("p", null, "You can undo deleting it until you close this window/tab"), _react.default.createElement(_default2.default, {
      onClick: this.handleRestoreDeleted
    }, "Undo delete")));
  }

  renderError(error) {
    return _react.default.createElement("div", {
      className: _DocumentPane.default.error
    }, _react.default.createElement("div", {
      className: _DocumentPane.default.errorInner
    }, _react.default.createElement("h3", null, "We\u2019re sorry, but your changes could not be applied."), _react.default.createElement(_UseState.default, {
      startWith: false
    }, (_ref6) => {
      var _ref7 = _slicedToArray(_ref6, 2),
          isExpanded = _ref7[0],
          setExpanded = _ref7[1];

      return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_default2.default, {
        onClick: () => this.setup(this.props.options.id)
      }, "Reload"), _react.default.createElement(_default2.default, {
        inverted: true,
        onClick: () => setExpanded(!isExpanded)
      }, isExpanded ? 'Hide' : 'Show', " details"), _react.default.createElement("div", null, isExpanded && _react.default.createElement("textarea", {
        className: _DocumentPane.default.errorDetails,
        onFocus: e => e.currentTarget.select(),
        value: error.stack
      })));
    })));
  }

  renderUnknownSchemaType() {
    var options = this.props.options;

    var _this$getDocumentSnap8 = this.getDocumentSnapshots(),
        draft = _this$getDocumentSnap8.draft,
        published = _this$getDocumentSnap8.published;

    var typeName = options.type;
    var doc = draft || published;
    return _react.default.createElement("div", {
      className: _DocumentPane.default.unknownSchemaType
    }, _react.default.createElement("div", {
      className: _DocumentPane.default.unknownSchemaTypeInner
    }, _react.default.createElement("h3", null, "Unknown schema type"), typeName && _react.default.createElement("p", null, "This document has the schema type ", _react.default.createElement("code", null, typeName), ", which is not defined as a type in the local content studio schema."), !typeName && _react.default.createElement("p", null, "This document does not exist, and no schema type was specified for it."), __DEV__ && doc && _react.default.createElement("div", null, _react.default.createElement("h4", null, "Here is the JSON representation of the document:"), _react.default.createElement("pre", {
      className: _DocumentPane.default.jsonDump
    }, _react.default.createElement("code", null, JSON.stringify(doc, null, 2))))));
  }

  getTitle(value) {
    var _this$props2 = this.props,
        paneTitle = _this$props2.title,
        options = _this$props2.options;
    var typeName = options.type;

    var type = _schema.default.get(typeName);

    if (paneTitle) {
      return _react.default.createElement("span", null, paneTitle);
    }

    if (this.historyIsOpen()) {
      return _react.default.createElement(_react.default.Fragment, null, "History of", ' ', _react.default.createElement(_preview.PreviewFields, {
        document: value,
        type: type,
        fields: ['title']
      }, (_ref8) => {
        var title = _ref8.title;
        return title ? _react.default.createElement("em", null, title) : _react.default.createElement("em", null, "Untitled");
      }));
    }

    if (!value) {
      return "New ".concat(type.title || type.name);
    }

    return _react.default.createElement(_preview.PreviewFields, {
      document: value,
      type: type,
      fields: ['title']
    }, (_ref9) => {
      var title = _ref9.title;
      return title ? _react.default.createElement("span", null, title) : _react.default.createElement("em", null, "Untitled");
    });
  }

  findSelectedHistoryEvent() {
    var selectedRev = this.props.urlParams.rev;
    return this.findHistoryEventByRev(selectedRev);
  }

  findHistoryEventByRev(rev) {
    var events = this.state.historyState.events;
    return rev === CURRENT_REVISION_FLAG ? events[0] : events.find(event => event.rev === rev || event.transactionIds.includes(rev));
  }

  getHistoryEventDateString() {
    var event = this.findSelectedHistoryEvent();
    var dateFormat = 'MMM D, YYYY, hh:mm A';
    var date = event && event.endTime;

    if (!date) {
      return '';
    }

    if ((0, _dateFns.isToday)(date)) {
      return "Today, ".concat((0, _dateFns.format)(date, 'hh:mm A'));
    }

    if ((0, _dateFns.isYesterday)(date)) {
      return "Yesterday, ".concat((0, _dateFns.format)(date, 'hh:mm A'));
    }

    return (0, _dateFns.format)(date, dateFormat);
  }

  renderHistorySpinner() {
    var isLoading = this.state.historical.isLoading;

    if (!isLoading) {
      return null;
    }

    var eventDate = this.getHistoryEventDateString();
    return _react.default.createElement(_Delay.default, {
      ms: 600
    }, _react.default.createElement("div", {
      className: _DocumentPane.default.spinnerContainer
    }, _react.default.createElement(_spinner.default, {
      center: true,
      message: "Loading revision".concat(eventDate ? " from ".concat(eventDate) : '', "\u2026")
    })));
  }

  renderCurrentView() {
    var initialValue = this.getInitialValue();
    var _this$props3 = this.props,
        views = _this$props3.views,
        options = _this$props3.options,
        urlParams = _this$props3.urlParams;
    var _this$state11 = this.state,
        draft = _this$state11.draft,
        published = _this$state11.published,
        historical = _this$state11.historical,
        markers = _this$state11.markers,
        isCreatingDraft = _this$state11.isCreatingDraft,
        isUnpublishing = _this$state11.isUnpublishing,
        isPublishing = _this$state11.isPublishing,
        isRestoring = _this$state11.isRestoring,
        isSaving = _this$state11.isSaving,
        validationPending = _this$state11.validationPending,
        isReconnecting = _this$state11.isReconnecting,
        historyState = _this$state11.historyState;
    var selectedHistoryEvent = this.findSelectedHistoryEvent();
    var typeName = options.type;

    var schemaType = _schema.default.get(typeName);

    var activeViewId = this.getActiveViewId();
    var activeView = views.find(view => view.id === activeViewId) || views[0] || {
      type: 'form'
    };
    var selectedIsLatest = urlParams.rev === CURRENT_REVISION_FLAG && selectedHistoryEvent === historyState.events[0]; // Should be null if not displaying a historical revision

    var historicalSnapshot = selectedIsLatest ? draft.snapshot || published.snapshot : historical.snapshot || historical.prevSnapshot;
    var viewProps = {
      // "Documents"
      document: {
        published: published.snapshot,
        draft: draft.snapshot,
        historical: historicalSnapshot,
        displayed: historicalSnapshot || draft.snapshot || published.snapshot || initialValue
      },
      // Other stuff
      documentId: this.getPublishedId(),
      options: activeView.options,
      schemaType,
      markers: markers || []
    };

    var formProps = _objectSpread({}, viewProps, {
      patchChannel: this.patchChannel,
      initialValue,
      validationPending,
      isRestoring,
      isSaving,
      isReconnecting,
      isPublishing,
      isUnpublishing,
      isCreatingDraft,
      history: {
        isOpen: this.historyIsOpen(),
        selectedEvent: selectedHistoryEvent,
        isLoadingEvents: historyState.isLoading,
        isLoadingSnapshot: historical.isLoading,
        document: selectedIsLatest ? {
          isLoading: !selectedHistoryEvent,
          snapshot: draft.snapshot || published.snapshot
        } : historical
      },
      onDelete: this.handleDelete,
      onPublish: this.handlePublish,
      onRestore: this.handleRestoreRevision,
      onUnpublish: this.handleUnpublish,
      onChange: this.handleChange
    });

    switch (activeView.type) {
      case 'form':
        return _react.default.createElement(_FormView.default, _extends({
          ref: this.formRef
        }, formProps));

      case 'component':
        return _react.default.createElement(activeView.component, viewProps);

      default:
        return null;
    }
  } // eslint-disable-next-line complexity


  render() {
    var _this$props4 = this.props,
        isSelected = _this$props4.isSelected,
        isCollapsed = _this$props4.isCollapsed,
        isClosable = _this$props4.isClosable,
        onCollapse = _this$props4.onCollapse,
        onExpand = _this$props4.onExpand,
        menuItemGroups = _this$props4.menuItemGroups,
        views = _this$props4.views,
        options = _this$props4.options,
        paneKey = _this$props4.paneKey;
    var _this$state12 = this.state,
        draft = _this$state12.draft,
        published = _this$state12.published,
        historical = _this$state12.historical,
        transactionResult = _this$state12.transactionResult,
        error = _this$state12.error,
        hasNarrowScreen = _this$state12.hasNarrowScreen,
        isReconnecting = _this$state12.isReconnecting,
        inspect = _this$state12.inspect,
        showConfirmDelete = _this$state12.showConfirmDelete,
        showConfirmUnpublish = _this$state12.showConfirmUnpublish,
        didPublish = _this$state12.didPublish,
        historyState = _this$state12.historyState;
    var typeName = options.type;

    var schemaType = _schema.default.get(typeName);

    if (!schemaType) {
      return this.renderUnknownSchemaType();
    }

    if (isRecoverable(draft, published)) {
      return this.renderDeleted();
    }

    if (error) {
      return this.renderError(error);
    }

    var isLoading = draft.isLoading || published.isLoading;

    if (isLoading) {
      return _react.default.createElement("div", {
        className: _DocumentPane.default.loading
      }, _react.default.createElement(_spinner.default, {
        center: true,
        message: "Loading ".concat(schemaType.title, "\u2026"),
        delay: 600
      }));
    }

    var selectedHistoryEvent = this.findSelectedHistoryEvent();
    var enabledActions = (0, _documentActionUtils.resolveEnabledActions)(schemaType);
    var historyIsOpen = this.historyIsOpen();
    var menuItems = (0, _documentPaneMenuItems2.getMenuItems)({
      enabledActions,
      draft: draft.snapshot,
      published: published.snapshot,
      isLiveEditEnabled: this.isLiveEditEnabled(),
      isHistoryEnabled: historyIsOpen,
      selectedEvent: historyIsOpen && selectedHistoryEvent,
      canShowHistoryList: this.canShowHistoryList()
    });
    var value = draft.snapshot || published.snapshot;
    return _react.default.createElement("div", {
      onKeyUp: this.handleKeyUp,
      className: this.historyIsOpen() ? _DocumentPane.default.paneWrapperWithHistory : _DocumentPane.default.paneWrapper
    }, this.historyIsOpen() && this.canShowHistoryList() && _react.default.createElement(_History.default, {
      key: "history",
      documentId: (0, _draftUtils.getPublishedId)(value._id),
      onClose: this.handleCloseHistory,
      onItemSelect: this.handleHistorySelect,
      lastEdited: value && new Date(value._updatedAt),
      published: published,
      draft: draft,
      events: historyState.events,
      isLoading: historyState.isLoading,
      error: historyState.error,
      selectedEvent: selectedHistoryEvent
    }), _react.default.createElement(_tabbed.default, {
      key: "pane",
      idPrefix: paneKey,
      title: this.getTitle(value),
      views: views,
      activeView: this.getActiveViewId(),
      onSetActiveView: this.handleSetActiveView,
      onSplitPane: hasNarrowScreen ? undefined : this.handleSplitPane,
      onCloseView: this.handleClosePane,
      menuItemGroups: menuItemGroups,
      isSelected: isSelected,
      isCollapsed: isCollapsed,
      onCollapse: onCollapse,
      onExpand: onExpand,
      onAction: this.handleMenuAction,
      menuItems: menuItems,
      footer: this.historyIsOpen() ? this.renderHistoryFooter() : this.renderFooter(),
      renderActions: this.renderActions,
      isClosable: isClosable,
      hasSiblings: this.context.hasGroupSiblings
    }, this.renderHistorySpinner(), this.renderCurrentView(), inspect && this.historyIsOpen() && historical && _react.default.createElement(_InspectHistory.default, {
      document: historical,
      onClose: this.handleHideInspector
    }), inspect && !this.historyIsOpen() && value && _react.default.createElement(_InspectView.default, {
      value: value,
      onClose: this.handleHideInspector
    }), showConfirmDelete && _react.default.createElement(_ConfirmDelete.default, {
      draft: draft.snapshot,
      published: published.snapshot,
      onCancel: this.handleCancelDelete,
      onConfirm: this.handleConfirmDelete
    }), showConfirmUnpublish && _react.default.createElement(_ConfirmUnpublish.default, {
      draft: draft.snapshot,
      published: published.snapshot,
      onCancel: this.handleCancelUnpublish,
      onConfirm: this.handleConfirmUnpublish
    }), isReconnecting && _react.default.createElement(_default3.default, {
      kind: "warning",
      isPersisted: true,
      title: "Connection lost. Reconnecting\u2026"
    }), didPublish && _react.default.createElement(_default3.default, {
      kind: "success",
      title: "You just published:",
      timeout: 3000 // eslint-disable-next-line react/jsx-no-bind
      ,
      onClose: () => this.setState({
        didPublish: false
      }),
      subtitle: _react.default.createElement(_DocTitle.default, {
        document: value
      })
    }), transactionResult && transactionResult.type === 'error' && _react.default.createElement(_default3.default, {
      kind: "error",
      actionTitle: "OK",
      onAction: this.handleClearTransactionResult,
      title: transactionResult.message,
      subtitle: _react.default.createElement("details", null, transactionResult.error.message)
    })));
  }

}, _defineProperty(_class, "contextType", _.PaneRouterContext), _defineProperty(_class, "propTypes", {
  styles: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  title: _propTypes.default.string,
  paneKey: _propTypes.default.string.isRequired,
  type: _propTypes.default.string.isRequired,
  isSelected: _propTypes.default.bool.isRequired,
  isCollapsed: _propTypes.default.bool.isRequired,
  isClosable: _propTypes.default.bool.isRequired,
  onExpand: _propTypes.default.func,
  onCollapse: _propTypes.default.func,
  menuItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    title: _propTypes.default.string.isRequired
  })),
  menuItemGroups: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired
  })),
  views: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    title: _propTypes.default.string.isRequired
  })),
  initialValue: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  options: _propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    type: _propTypes.default.string.isRequired,
    template: _propTypes.default.string
  }).isRequired,
  urlParams: _propTypes.default.shape({
    view: _propTypes.default.string,
    rev: _propTypes.default.string
  }).isRequired
}), _defineProperty(_class, "defaultProps", {
  title: '',
  views: [],
  menuItems: [],
  menuItemGroups: [],
  styles: undefined,
  onExpand: undefined,
  onCollapse: undefined,
  initialValue: undefined
}), _temp));

exports.default = _default;